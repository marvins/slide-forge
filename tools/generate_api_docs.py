#!/usr/bin/env python3
# Copyright (c) 2026 Slide Forge Team
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Generate Markdown API docs from Slide Forge modules."""

from __future__ import annotations

import importlib
import inspect
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable


@dataclass
class ModuleSpec:
    title: str
    module: str


MODULES: list[ModuleSpec] = [
    ModuleSpec("Core", "slideforge.core"),
    ModuleSpec("Parsers", "slideforge.parsers.latex_parser"),
    ModuleSpec("Mappers", "slideforge.mappers.content_mapper"),
    ModuleSpec("Builders", "slideforge.builders.powerpoint_builder"),
    ModuleSpec("Models", "slideforge.models.universal"),
    ModuleSpec("Exceptions", "slideforge.exceptions"),
    ModuleSpec("CLI", "slideforge.apps.cli"),
]


def _iter_public_classes(module) -> Iterable[type]:
    for name, obj in inspect.getmembers(module, inspect.isclass):
        if obj.__module__ != module.__name__:
            continue
        if name.startswith("_"):
            continue
        yield obj


def _iter_public_functions(module) -> Iterable[callable]:
    for name, obj in inspect.getmembers(module, inspect.isfunction):
        if obj.__module__ != module.__name__:
            continue
        if name.startswith("_"):
            continue
        yield obj


def _format_signature(obj) -> str:
    try:
        return str(inspect.signature(obj))
    except (TypeError, ValueError):
        return "()"


def _write_module_section(lines: list[str], spec: ModuleSpec) -> None:
    module = importlib.import_module(spec.module)
    lines.append(f"## {spec.title}\n")
    lines.append(f"**Module:** `{spec.module}`\n")

    classes = list(_iter_public_classes(module))
    functions = list(_iter_public_functions(module))

    if classes:
        lines.append("### Classes\n")
        for cls in classes:
            lines.append(f"#### `{cls.__name__}`\n")
            lines.append(f"`{cls.__name__}{_format_signature(cls)}`\n")
            doc = inspect.getdoc(cls) or "No class docstring provided."
            lines.append(f"{doc}\n")

            methods = [m for m in inspect.getmembers(cls, inspect.isfunction) if not m[0].startswith("_")]
            if methods:
                lines.append("**Methods**\n")
                for name, method in methods:
                    lines.append(f"- `{name}{_format_signature(method)}`")
                lines.append("")

    if functions:
        lines.append("### Functions\n")
        for func in functions:
            lines.append(f"#### `{func.__name__}`\n")
            lines.append(f"`{func.__name__}{_format_signature(func)}`\n")
            doc = inspect.getdoc(func) or "No function docstring provided."
            lines.append(f"{doc}\n")

    if not classes and not functions:
        lines.append("No public classes or functions documented.\n")


def generate_api_docs(output_path: Path) -> None:
    lines: list[str] = []
    lines.append("# Auto-Generated API Documentation\n")
    lines.append("This file is generated by `tools/generate_api_docs.py`.\n")
    lines.append("Do not edit manually. Update docstrings in the source code instead.\n")

    for spec in MODULES:
        _write_module_section(lines, spec)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


if __name__ == "__main__":
    repo_root = Path(__file__).resolve().parents[1]
    output = repo_root / "docs" / "book" / "api" / "auto.md"
    generate_api_docs(output)
    print(f"Generated API docs at {output}")
